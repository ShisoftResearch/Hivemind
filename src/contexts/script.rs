// Composer build chained generic traits objects just like iterator in rust.
// It can be compiled into serializable expression object, deliver to remote nodes and compile to
//  runtime objects.
// To make a runnable RDD, there will be 3 parts.
//  1. The generic trait objects that generated by composer.
//  2. Serialized RDD expressions compiled by composer
//  3. Runtime RDD with function closure, partitioner etc.
// Composer utilized rust type system ensured type safety when composing RDDs.
// The RDD runtime use dynamic typing heavily by 'Any' trait for transformers, which will also
//  produce errors if type mismatch. But we can detected such error at compile time by the composer.

use std::collections::BTreeMap;
use std::marker::PhantomData;
use std::rc::Rc;
use rdd::funcs::RDDFunc;
use rdd::{RDDID, RDDTracker};
use rdd::script::{RDDScript, RDDScriptCtx};
use rdd::{transformers as trans};
use rdd::dependency::DependencyScript;
use scheduler::dag::DAGScheduler;
use bifrost::utils::bincode;
use super::JobContext;

// only for context transport
#[derive(Serialize, Deserialize)]
pub struct ScriptContext {
    pub dag: BTreeMap<RDDID, RDDScript>,
    pub stages: BTreeMap<u32, DAGScheduler>,
    pub start: RDDID
}

pub trait RDDComposer: Clone {
    type Item;
    fn id(&self) -> RDDID;
    fn map<F>(&self, closure: F) -> Map<Self, F>
        where Self: Sized,
              F: RDDFunc<In = (Self::Item, )>
    {
        Map { comp: self.clone(), func: closure, id: RDDID::rand() }
    }

    fn filter<F>(&self, closure: F) -> Filter<Self, F, Self::Item>
        where Self: Sized,
              F: RDDFunc<In = (Self::Item, )>
    {
        Filter { comp: self.clone(), func: closure, id: RDDID::rand(), mark: PhantomData }
    }
    fn compile(&self, ctx: &mut ScriptContext);
    fn compile_with_closure<F>(
        &self,
        rdd_id: RDDID,
        closure: &F,
        trans_id: u64,
        ctx: &mut ScriptContext,
        deps: Vec<DependencyScript>,
    )
        where F: RDDFunc
    {
        // we encode encode closure data and put the func_id within script data
        //  so that the transformer constructor can decode the closure data by func_id
        let func_id = F::id();
        let closure_data =  bincode::serialize(closure);
        ctx.dag.insert(rdd_id, RDDScript {
            rdd_id,
            ctx: RDDScriptCtx::Transformer {
                id: trans_id,
                data: bincode::serialize(&(func_id, closure_data))
            },
            deps,
        });
    }
}

#[derive(Clone)]
pub struct Filter<C, F, I> {
    comp: C,
    func: F,
    id: RDDID,
    mark: PhantomData<I>
}

impl <C, F, I> RDDComposer for Filter<C, F, I>
    where F: RDDFunc,
          I: Clone,
          C: RDDComposer {
    type Item = I;
    fn compile(&self, ctx: &mut ScriptContext) {
        self.comp.compile(ctx);
        self.compile_with_closure(
            self.id,
            &self.func,
            trans::filter::Filter::trans_id(),
            ctx,
            vec![DependencyScript::Narrow(self.comp.id())]
        )
    }
    fn id(&self) -> RDDID {
        self.id
    }
}

#[derive(Clone)]
pub struct Map<C, F> {
    comp: C,
    func: F,
    id: RDDID
}

impl <C, F> RDDComposer for Map<C, F>
    where F: RDDFunc,
          C: RDDComposer {
    type Item = F::Out;
    fn compile(&self, ctx: &mut ScriptContext) {
        self.comp.compile(ctx);
        self.compile_with_closure(
            self.id,
            &self.func,
            trans::map::Map::trans_id(),
            ctx,
            vec![DependencyScript::Narrow(self.comp.id())]
        );
    }
    fn id(&self) -> RDDID {
        self.id
    }
}

impl ScriptContext {
    pub fn compile_to_job(&self) -> Result<JobContext, String> {
        let mut runtime_ctx = JobContext::new();
        for (id, script) in &self.dag {
            let compiled_scr = script.compile()?;
            runtime_ctx.rdds.insert(*id, compiled_scr);
        }
        return Ok(runtime_ctx);
    }
    pub fn compile_rdd<RDD>(&mut self, rdd: RDD) where RDD: RDDComposer {
        rdd.compile(self);
        self.start = rdd.id();
    }
    pub fn new() -> ScriptContext {
        ScriptContext {
            start: RDDID::unit(),
            dag: BTreeMap::new(),
            stages: BTreeMap::new(),
        }
    }
}

mod test {
    use INIT_LOCK;
    use super::*;
    use rdd::funcs::RDDFuncResult;
    use rdd::transformers;
    use rdd::RDDTracker;

    def_rdd_func!(
        APlusB (a: u64)[b: u64] -> u64 {
            a + b
        }
        AGreaterThanN(x: u64)[n: u64] -> bool {
            x > n
        }
    );

    #[derive(Clone)]
    struct Dummy;
    impl RDDComposer for Dummy {
        fn compile(&self, ctx: &mut ScriptContext) {}
        fn id(&self) -> RDDID {
            RDDID::unit()
        }
        type Item = u64;
    }

    #[test]
    fn composer() {
        let lock = INIT_LOCK.lock();
        transformers::map::Map::register();
        transformers::filter::Filter::register();
        APlusB::register().unwrap();
        AGreaterThanN::register().unwrap();
        let mut context = ScriptContext::new();
        let dum = Dummy{};
        let rdd = dum
            .map(APlusB{b: 10})
            .filter(AGreaterThanN{ n: 5 })
            .map(APlusB{b: 5});
        context.compile_rdd(rdd);
        assert_eq!(context.dag.len(), 3);
        let job = context.compile_to_job().unwrap();
    }
}
